pragma solidity >0.5.0 <=0.6.3;

// receiver only able to view his own escrows
// sender only able to view his own escrows too
// this cannot be done in Solidity because would need an array for each address in escrow (looping through map is infeasible)
// for react app can store all of this information in localStorage

contract PrivateEscrow {
    address owner;
    mapping(bytes32 => Escrow) private escrows;

    struct Escrow {
        bool exists;
        bool senderApproved;
        bool receiverApproved;
    }

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "action not allowed");
        _;
    }

    modifier onlyEscrowParties(
        address payable sender,
        address payable receiver
    ) {
        // bytes32 tradeHash = getEscrowHash(escrowID, sender, receiver, value);
        // require(escrows[tradeHash].exists, "escrow not found"); // verifies that the caller knows the details of the escrow
        // // verifies that the caller is either the sender or the receiver. it is not enough to know the details of the escrow
        require(msg.sender == sender || msg.sender == receiver, "not allowed");
        _;
    }

    function getEscrow(
        bytes16 escrowID,
        address payable sender,
        address payable receiver
    )
        private
        view
        returns (
            // uint16 fee
            Escrow memory
        )
    {
        bytes32 tradeHash = getEscrowHash(escrowID, sender, receiver);
        return escrows[tradeHash];
    }

    function getEscrowHash(
        bytes16 escrowID,
        address payable sender,
        address payable receiver
    )
        private
        pure
        returns (
            // uint16 fee
            bytes32 hash
        )
    {
        bytes32 tradeHash = keccak256(
            abi.encodePacked(escrowID, sender, receiver)
        );
        return tradeHash;
    }

    function escrowExists(
        /**
        * Used to verify that the escrow exists. Proof-of-funds.
        */
        bytes16 escrowID,
        address payable sender,
        address payable receiver
    )
        public
        view
        returns (
            // uint16 fee // how much we earn off the trasnsaction
            bool
        )
    {
        bytes32 tradeHash = getEscrowHash(escrowID, sender, receiver);
        return escrows[tradeHash].exists;
    }

    function createEscrow(
        /**
        * Create a new escrow and add it to `escrows`.
        * _tradeHash is created by hashing _escrowID, _seller, _buyer, _value and _fee variables
        */
        bytes16 escrowID, // The unique ID of the trade, generated by localethereum.com
        address payable receiver, // The party that receives the funds from the escrow
        uint256 value // The zDAI amount being held in escrow // uint16 fee // the fee that we earn
    ) external payable {
        address payable sender = msg.sender;
        bytes32 tradeHash = getEscrowHash(escrowID, sender, receiver);
        require(!escrows[tradeHash].exists, "could not find escrow"); // Require that trade does not already exist
        require(msg.value == value && msg.value > 0, "incorrect value"); // Check sent eth against signed _value and make sure is not 0
        escrows[tradeHash] = Escrow(true, false, false); // * keep struct in case need to add anything else in there
    }

    // a trade can only be approved by either the sender or receiver or both you cannot approve more than once
    // - require that this party has not approved before (not necessary because a bool flag; perhaps, useful for saving the gas)
    // - approve
    function approve(
        bytes16 escrowID,
        address payable sender,
        address payable receiver
    ) external onlyEscrowParties(sender, receiver) {
        bytes32 tradeHash = getEscrowHash(escrowID, sender, receiver);
        require(escrows[tradeHash].exists, "escrow not found");
        // the modifier requires that either the sender or the caller called the approve function
        // so if not sender called this, then it must be that the receiver called it
        if (msg.sender == sender) {
            require(
                !escrows[tradeHash].senderApproved,
                "already approved by you"
            );
            escrows[tradeHash].senderApproved = true;
        } else {
            require(
                !escrows[tradeHash].receiverApproved,
                "already approved by you"
            );
            escrows[tradeHash].receiverApproved = true;
        }
    }

    // sender or receiver releases
    // - require that either sender or the receiver called the function ✔️
    // - require that the escrow exists (this also confirms that the sender and the receiver are valid too) ✔️
    // - require that both of the approves are available
    // - delete
    // - release the funds to receiver
    function release(
        bytes16 escrowID,
        address payable sender,
        address payable receiver,
        uint256 value
    ) external payable onlyEscrowParties(sender, receiver) returns (bool) {
        bytes32 tradeHash = getEscrowHash(escrowID, sender, receiver);
        require(escrows[tradeHash].exists, "escrow not found");
        require(
            escrows[tradeHash].senderApproved &&
                escrows[tradeHash].receiverApproved,
            "not approved"
        );
        delete escrows[tradeHash];
        receiver.transfer(value);
        return true; // does this function ever return false?
    }
}

// Testing protocol
// 1. create escrow with sender
// 2. switch account to receiver and check that the funds are in
// 3. receiver approves
// 4. sender approves
// 5. release the money (test from both the receiver and the sender side)

// Note:
// 1. if someone knows the sender and the receiver they can brute force the value. This will give them information about the value of the escrow, the very thing that should be private
// - if value with Aztec is a hash, then this is not a problem. It would take them too long to brute force
// - if the value with Aztec is not a hash, then I should generate a "random" hash and give that back upon creation of the escrow to both parties. this will fix the issue

